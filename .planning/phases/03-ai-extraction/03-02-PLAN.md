---
phase: 03-ai-extraction
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/actions/extraction.ts
  - src/lib/actions/products.ts
autonomous: true

must_haves:
  truths:
    - "Server Action accepts file upload and returns extracted data"
    - "Extraction validates file type (.txt, .md) and size (50KB limit)"
    - "Gemini returns structured JSON matching extraction schema"
    - "createProduct action can save new products to database"
  artifacts:
    - path: "src/lib/actions/extraction.ts"
      provides: "extractFromProductSheet Server Action"
      exports: ["extractFromProductSheet"]
    - path: "src/lib/actions/products.ts"
      provides: "createProduct Server Action"
      exports: ["createProduct"]
  key_links:
    - from: "src/lib/actions/extraction.ts"
      to: "src/lib/gemini/client.ts"
      via: "import ai, EXTRACTION_MODEL"
      pattern: "import.*from.*gemini/client"
    - from: "src/lib/actions/extraction.ts"
      to: "src/lib/schemas/extraction.ts"
      via: "import schema and JSON Schema"
      pattern: "extractedProductSchema.*parse"
    - from: "src/lib/actions/extraction.ts"
      to: "Gemini API"
      via: "ai.models.generateContent with responseJsonSchema"
      pattern: "responseMimeType.*application/json"
---

<objective>
Create Server Actions for product extraction and creation.

Purpose: Enable AI-powered extraction from uploaded files and saving new products to database.
Output: Two Server Actions - extractFromProductSheet for AI extraction, createProduct for database save.
</objective>

<execution_context>
@C:\Users\kazda\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\kazda\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-ai-extraction/03-RESEARCH.md
@src/lib/gemini/client.ts
@src/lib/schemas/extraction.ts
@src/lib/actions/products.ts
@src/lib/schemas/product.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extraction Server Action</name>
  <files>src/lib/actions/extraction.ts</files>
  <action>
Create `src/lib/actions/extraction.ts` with `extractFromProductSheet` Server Action:

1. Mark as "use server" at top
2. Import ai, EXTRACTION_MODEL from gemini/client
3. Import extractedProductSchema, extractedProductJsonSchema, ExtractedProduct from schemas/extraction
4. Define ExtractionResult interface:
   ```typescript
   interface ExtractionResult {
     success: boolean;
     data?: ExtractedProduct;
     error?: string;
   }
   ```

5. Implement extractFromProductSheet(formData: FormData): Promise<ExtractionResult>
   - Get file from formData.get("file")
   - Validate file exists (return error if not)
   - Validate file extension is .txt or .md (return error if not)
   - Get file content via file.text()
   - Validate content length <= 50000 chars (return error "File too large (max 50KB)" if not)
   - Call Gemini with structured output:
     ```typescript
     const response = await ai.models.generateContent({
       model: EXTRACTION_MODEL,
       contents: buildExtractionPrompt(content),
       config: {
         responseMimeType: "application/json",
         responseJsonSchema: extractedProductJsonSchema,
       },
     });
     ```
   - Parse response.text as JSON
   - Validate with extractedProductSchema.parse()
   - Return { success: true, data: validated }
   - Wrap in try/catch, return { success: false, error: message } on failure

6. Create buildExtractionPrompt(content: string): string helper:
   ```typescript
   function buildExtractionPrompt(content: string): string {
     return `You are a medical device data extraction assistant. Extract structured product information from the following vendor product sheet.

IMPORTANT GUIDELINES:
- Extract exactly what is stated; do not infer missing data
- For price, extract numeric value only (no currency symbols)
- For EMDN, suggest code from orthopedic categories: P09 (bone/prosthetic), P0901 (bone implants), P0902 (joint implants), P10 (external devices)
- For MDR class, only extract if explicitly stated (I, IIa, IIb, or III)
- Set fields to null if information is not found

VENDOR PRODUCT SHEET:
${content}`;
   }
   ```

Error handling: Log errors to console but return user-friendly messages (not stack traces).
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
File exports extractFromProductSheet function
  </verify>
  <done>extractFromProductSheet Server Action accepts FormData, validates file, calls Gemini, returns typed extraction result</done>
</task>

<task type="auto">
  <name>Task 2: Add createProduct Server Action</name>
  <files>src/lib/actions/products.ts</files>
  <action>
Extend `src/lib/actions/products.ts` to add createProduct action:

1. Add new function createProduct(formData: FormData): Promise<ActionResult>
2. Follow same pattern as updateProduct:
   - Convert FormData to object
   - Handle boolean conversion for ce_marked
   - Convert empty strings to null for nullable fields
   - Validate with productSchema.safeParse
   - If invalid, return { error: validatedData.error.flatten() }

3. Insert into database:
   ```typescript
   const { data, error } = await supabase
     .from("products")
     .insert(validatedData.data)
     .select()
     .single();
   ```

4. Handle errors, revalidatePath("/"), return { success: true }

5. Optionally return the created product ID in result:
   ```typescript
   interface ActionResult {
     success?: boolean;
     productId?: string;  // Add this for create
     error?: { ... };
   }
   ```

Keep existing updateProduct and deleteProduct unchanged.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
File exports createProduct, updateProduct, deleteProduct
  </verify>
  <done>createProduct Server Action validates input, inserts to database, revalidates cache</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. src/lib/actions/extraction.ts exports extractFromProductSheet
3. src/lib/actions/products.ts exports createProduct (alongside existing exports)
</verification>

<success_criteria>
- extractFromProductSheet validates file, calls Gemini with structured output, returns typed result
- createProduct follows existing action patterns, inserts to products table
- Both actions handle errors gracefully with user-friendly messages
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-extraction/03-02-SUMMARY.md`
</output>
