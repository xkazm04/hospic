---
phase: 10-context-and-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/components/chat/error-bubble.tsx
  - src/components/chat/chat-panel.tsx
  - src/components/chat/chat-input.tsx
autonomous: true

must_haves:
  truths:
    - "User sees friendly error message when API fails"
    - "Retry button appears only for retryable errors (not rate limits)"
    - "One automatic silent retry happens before showing error to user"
    - "Chat blocks at 50 messages with clear guidance"
    - "User can clear chat via overflow menu"
  artifacts:
    - path: "src/components/chat/error-bubble.tsx"
      provides: "Error display component with conditional retry"
      exports: ["ErrorBubble"]
    - path: "src/components/chat/chat-panel.tsx"
      provides: "Chat panel with error handling and message limits"
      contains: "onError"
    - path: "src/components/chat/chat-input.tsx"
      provides: "Chat input with disabled state for chat full"
      contains: "disabled"
  key_links:
    - from: "src/components/chat/chat-panel.tsx"
      to: "src/lib/chat/errors.ts"
      via: "classifyError import"
      pattern: "import.*classifyError.*from.*errors"
    - from: "src/components/chat/chat-panel.tsx"
      to: "@ai-sdk/react useChat"
      via: "error, clearError, regenerate, setMessages"
      pattern: "error.*clearError.*regenerate"
---

<objective>
Add error UI and message limit handling to the chat interface - ErrorBubble component for displaying errors with retry, ChatPanel wiring for error state management with auto-retry, and clear chat functionality.

Purpose: Complete the error handling user experience so users see friendly messages instead of raw errors, can retry when appropriate, and understand when chat is full.

Output: ErrorBubble component, enhanced ChatPanel with full error handling and message limits, ChatInput with disabled state.
</objective>

<execution_context>
@C:\Users\mkdol\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\mkdol\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-context-and-error-handling/10-CONTEXT.md
@.planning/phases/10-context-and-error-handling/10-RESEARCH.md
@.planning/phases/10-context-and-error-handling/10-01-SUMMARY.md
@src/components/chat/chat-panel.tsx
@src/components/chat/chat-input.tsx
@src/components/chat/message-bubble.tsx
@src/lib/chat/errors.ts
@src/lib/chat/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBubble component</name>
  <files>src/components/chat/error-bubble.tsx</files>
  <action>
Create `src/components/chat/error-bubble.tsx`:

1. Props interface:
   - `message: string` - The user-friendly error message
   - `isRetryable: boolean` - Whether to show retry button
   - `onRetry?: () => void` - Callback for retry button

2. Styling per CONTEXT.md (red/warning bubble, distinct from normal chat):
   - Use destructive color theme: `bg-destructive/10 text-destructive border border-destructive/20`
   - Rounded corners matching message bubbles: `rounded-2xl rounded-bl-md`
   - Left-aligned (like assistant messages): `flex justify-start`
   - Max width: `max-w-[85%]`
   - Padding: `px-4 py-2.5`

3. Retry button (only if isRetryable && onRetry):
   - Text: "Try again"
   - Style: `text-xs underline hover:no-underline`
   - Margin top: `mt-2`

4. Mark as 'use client' for interactivity

Example structure:
```tsx
<div className="flex justify-start mb-3">
  <div className="max-w-[85%] px-4 py-2.5 bg-destructive/10 text-destructive border border-destructive/20 rounded-2xl rounded-bl-md">
    <p className="text-sm">{message}</p>
    {isRetryable && onRetry && (
      <button onClick={onRetry} className="mt-2 text-xs underline hover:no-underline">
        Try again
      </button>
    )}
  </div>
</div>
```
  </action>
  <verify>
Component renders: Add temporary import in chat-panel.tsx and render with test props
  </verify>
  <done>
ErrorBubble component displays error message with red/warning styling. Retry button only appears when isRetryable is true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire error handling and message limits in ChatPanel</name>
  <files>src/components/chat/chat-panel.tsx</files>
  <action>
Update `src/components/chat/chat-panel.tsx`:

1. Add imports:
   - `{ useState, useEffect }` from 'react' (useState new)
   - `{ classifyError }` from '@/lib/chat/errors'
   - `{ MAX_MESSAGES, CHAT_FULL_MESSAGE }` from '@/lib/chat/constants'
   - `{ ErrorBubble }` from './error-bubble'

2. Destructure additional useChat returns:
   - `error`, `clearError`, `regenerate`, `setMessages`
   - Existing: messages, sendMessage, status, stop

3. Add auto-retry state:
   - `const [retryAttempted, setRetryAttempted] = useState(false)`

4. Add auto-retry effect:
```tsx
useEffect(() => {
  if (status === 'error' && error && !retryAttempted) {
    const classified = classifyError(error);
    if (classified.isRetryable) {
      setRetryAttempted(true);
      regenerate(); // Silent auto-retry
    }
  }
  // Reset retry flag when not in error state
  if (status !== 'error') {
    setRetryAttempted(false);
  }
}, [status, error, retryAttempted, regenerate]);
```

5. Add message limit check:
```tsx
const isChatFull = messages.length >= MAX_MESSAGES;
```

6. Update handleSubmit to block when full:
```tsx
const handleSubmit = (text: string) => {
  if (isChatFull) return; // Blocked - UI shows chat full message
  if (text.trim()) {
    clearError(); // Clear any previous error
    sendMessage({ text });
  }
};
```

7. Add retry handler:
```tsx
const handleRetry = () => {
  clearError();
  regenerate();
};
```

8. Add clear chat handler:
```tsx
const handleClearChat = () => {
  setMessages([]);
  clearError();
  setRetryAttempted(false);
};
```

9. Compute error state for display:
```tsx
const showError = status === 'error' && error && retryAttempted;
const classifiedError = showError ? classifyError(error) : null;
```

10. Update render to show ErrorBubble after MessageList (before ChatInput):
```tsx
{showError && classifiedError && (
  <ErrorBubble
    message={classifiedError.userMessage}
    isRetryable={classifiedError.isRetryable}
    onRetry={classifiedError.isRetryable ? handleRetry : undefined}
  />
)}
```

11. Pass `isChatFull` and `onClearChat` to ChatInput:
```tsx
<ChatInput
  onSubmit={handleSubmit}
  disabled={isStreaming || isChatFull}
  isChatFull={isChatFull}
  onClearChat={handleClearChat}
/>
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/components/chat/chat-panel.tsx`
  </verify>
  <done>
ChatPanel handles errors with auto-retry (once, silent, not for rate limits), displays ErrorBubble after retry fails, blocks input at 50 messages, and provides clear chat function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ChatInput for chat full state and clear action</name>
  <files>src/components/chat/chat-input.tsx</files>
  <action>
Update `src/components/chat/chat-input.tsx`:

1. Update props interface:
```tsx
interface ChatInputProps {
  onSubmit: (text: string) => void;
  disabled?: boolean;
  isChatFull?: boolean;
  onClearChat?: () => void;
}
```

2. Add clear button to overflow menu (create if doesn't exist):
   - If no overflow menu exists, add a simple button next to send
   - Use MoreVertical icon from lucide-react for overflow trigger
   - Or add "Clear" text button if keeping simple

3. When `isChatFull` is true:
   - Show `CHAT_FULL_MESSAGE` ("Chat full. Clear to continue.") instead of input
   - Show clear button prominently
   - Input field hidden or replaced with message

Simple implementation (no dropdown complexity):
```tsx
{isChatFull ? (
  <div className="flex items-center justify-between gap-2 p-3">
    <span className="text-sm text-muted-foreground">{CHAT_FULL_MESSAGE}</span>
    <Button onClick={onClearChat} variant="outline" size="sm">
      Clear chat
    </Button>
  </div>
) : (
  // Existing input form
  <form onSubmit={handleSubmit} className="...">
    ...
    {onClearChat && (
      <Button
        type="button"
        onClick={onClearChat}
        variant="ghost"
        size="icon"
        className="text-muted-foreground"
        title="Clear chat"
      >
        <Trash2 className="h-4 w-4" />
      </Button>
    )}
  </form>
)}
```

4. Import required:
   - `CHAT_FULL_MESSAGE` from '@/lib/chat/constants'
   - `Trash2` from 'lucide-react' (or X icon)
   - `Button` from '@/components/ui/button'
  </action>
  <verify>
`npm run build` succeeds
Visual test: Run dev server, verify chat input shows clear button, test sending 50+ messages (or temporarily set MAX_MESSAGES=3) to see blocking state
  </verify>
  <done>
ChatInput shows "Chat full. Clear to continue." with clear button when at message limit. Clear button available in normal state via overflow/icon.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Start dev server: `npm run dev`
3. Open chat widget
4. Test error handling:
   - Temporarily break API (invalid API key) to trigger error
   - Verify auto-retry happens (check network tab - 2 requests)
   - Verify error bubble appears with friendly message
   - Verify retry button works (for non-rate-limit errors)
5. Test message limit:
   - Temporarily set MAX_MESSAGES=3 in constants.ts
   - Send 3 messages
   - Verify input shows "Chat full. Clear to continue."
   - Click clear, verify chat empties and input returns
6. Reset MAX_MESSAGES to 50
</verification>

<success_criteria>
- ErrorBubble displays with red/warning styling
- Auto-retry happens once silently before showing error
- Rate limit errors do NOT get retry button
- Network/timeout errors DO get retry button
- Chat blocks at 50 messages with clear guidance
- Clear chat empties messages and restores input
- All components type-check without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-context-and-error-handling/10-02-SUMMARY.md`
</output>
